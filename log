#!/usr/bin/python

"""
This script prints a hierarchical log of git history that is designed to be
human readable.  It has these characteristics: 

* "Mainline" history goes down the left-hand side

* Following a merge commit, commits which were merged into "mainline" by that
merge are listed indented and marked with an indentation guide.

* Each commit is listed only once.  Commits will NOT be displayed in right-hand
side merge if they are also part of the LHS.  

* Pulls are detecetd and displayed as a merge into mainline

* Thus, it's easy to eyeball what got merged into mainline, and when.

Recommended usage: 
cd yourGitDir
log | less -S
"""

import subprocess
from subprocess import PIPE
import sys
import re

class IndentPrinter(object):
	"""Utility to print lines at a given indent level."""
	def __init__(self, level=0, width=4):
		self.level = level
		self.width = width
		prefix = "|" + " " * (width - 1)
		prefix = prefix * level
		self.prefix = prefix

	def println(self, lines):
		for line in str(lines).split("\n"):
			print(self.prefix + line)
		sys.stdout.flush()

	def indent(self):
		return IndentPrinter(level=self.level + 1, width=self.width)
		
class GitIndent(IndentPrinter):
	"""This indenter remembers the context of the commits which it is outputting. 
	This allows us to check that we're not displaying duplicate entries inside of indent.
	"""
	def __init__(self, level=0, width=4, parent=None):
		IndentPrinter.__init__(self, level=level, width=width)
		self.parent = parent
		# Which commits should we print in this indentation level?
		self.limit_commits = None

		self.__calculated = False
		self.__commits = []
		
	def indent(self, limit_commits, level=None):
		# Defualt to one more level of indentation, unless overridden:
		if not level:
			level = self.level + 1
			
		inner = GitIndent(
			level=level
			, width=self.width
			, parent=self
		)
		
		# If our parent is already limited, we're limited to a subset of those:
		if self.parent is not None and self.parent.limit_commits is not None: 
			limit_commits = limit_commits.intersection(self.parent.limit_commits)
		
		inner.limit_commits = limit_commits
		return inner
		
	def should_print(self, commit):
		if self.limit_commits is None:
			# not set, we're the LHS, print everything.
			return True
		else: return commit in self.limit_commits
		
		
		
		
def contains(commit, *other_commits):
	"""Return true iff commit is included in the history of any of other_commits."""
	
	if len(other_commits) == 0: return False
	
	cmd = ["git", "merge-base", "--independent", commit]
	cmd.extend(other_commits)
	#print repr(cmd)
	
	p = subprocess.Popen(cmd, stderr=PIPE, stdout=PIPE)
	(out, err) = p.communicate()
	if err:
		raise Exception(err)
	lines = out.split("\n")
	
	# commit is included in other_commits if it is not independent:
	#print repr(lines)
	return commit not in lines
	
	

def memoizer():
	"""Create a memorizer decorator that has its own cache."""
	cache = {}
	
	def decorator(inner_fn):
		def new_fn(*args, **kwargs):
			key = (args, kwargs)
			if cache.has_key(key): return cache[key]
			# else:
			value = inner_fn(*args, **kwargs)
			cache[key] = value
			return value
			
		return new_fn
		
	return decorator


def get_output(*cmd):
	"""Run a command and return its output."""	
	p = subprocess.Popen(cmd, stderr=PIPE, stdout=PIPE)
	(out, err) = p.communicate()
	if err: 
		raise Exception(err)
	return out

# The Directed Acyclic Graph of Git history by commit ID: 
__dag = {}
def read_dag(commit):
	"""Read the DAG from Git into memory."""
	out = get_output("git", "rev-list", "--parents", commit)
	lines = out.split("\n")
	for line in lines: 
		commits = line.split(" ")
		commit = commits[0]
		parents = commits[1:]
		__dag[commit] = parents
	
def get_commit_set(commit):
	"""Return a set that contains all parents of the given commit. (inclusive)"""
	if not __dag.has_key(commit): read_dag(commit)

	to_search = [commit]
	result = set()

	while to_search:
		commit = to_search.pop()
		if commit in result: continue # Some other merge already got this history
		result.add(commit)
		parents = __dag[commit]
		to_search.extend(parents)

	return result
	
def git_unique_commits(commit, others):
	"""Return a set of commits found in the history of commit, but not others."""
	if len(others) < 1:
		raise Exception("Others can't be empty. At least not if you want a small set of commits.")
	cmd = ["git", "log", "--pretty=format:%H", commit, "--not"]
	cmd.extend(others)
	return set(get_output(*cmd).split("\n"))
	

# TODO: Make this a cache:
__commits = {}
def lookup_commit(commit):
	"""Get a cached CommitInfo.  Otherwise look up a batch of them to save on calls to git."""
	if __commits.has_key(commit): return __commits[commit]
	else: return fetch_commits(commit)

def fetch_commits(commit, fetch=1000):
	out = get_output("git", "log", "-n", str(fetch), "--parents", "--no-decorate", commit)
	lines = out.split("\n")
	log_lines = []
	infos = []
	for line in lines:
		if line.startswith("commit ") and log_lines:	
			#Add the previous commit to the cache: 
			infos.append(CommitInfo(log_lines))
			log_lines = []
		log_lines.append(line)
	# Catch the last commit:
	if log_lines:
		infos.append(CommitInfo(log_lines))

	# Add them to the cache:
	for info in infos: __commits[info.commit] = info
	# Return the first one.  The name we used to look it up 
	# Might not match its commit.  (Ex: HEAD) 
	return infos[0]
			
			
	

# The sortof key/value pattern used in git log:
__kv_pat = re.compile("^([^: ]+):?[ ]+(.*)$")

def getKeyValue(line):
	"""Split a line up into its key/value pair, returned as a tuple."""
	match = __kv_pat.match(line)
	if not match: raise "Not a key/value line: " + line
	return match.group(1,2)
	
def remove_message_padding(line):
	"""Git commit messages are padded with 4 spaces.  This removes them."""	
	return line[4:]

class CommitInfo(object):
	@staticmethod
	def from_commit(commit):
		#return CommitInfo(getCommit(commit))
		return lookup_commit(commit)

	def __init__(self, lines):
		data = {}
		count = 0
		for line in lines:	
			if not line: break # end on blank line
			(k,v) = getKeyValue(line)
			data[k] = v
			count = count + 1

		# Break parents out of the commit:
		commit = data["commit"].split(" ")
		self.commit = commit[0]
		self.parents = commit[1:]
		# Save the original order in case parents get reordered: 
		self.orig_parents = self.parents[:]
		self.date = data["Date"]
		self.author = data["Author"]
		
		# Count is a blank line.
		# Git outputs a line return after the messages so the CLI will be on a new line
		# But it's not part of the message:
		message_lines = lines[count+1:-1]
		self.message = message_lines

		# Calculate whether the LHS needs to be changed to simplify logging:
		self.__calc_lhs()
		
		

	def __str__(self):
		s =       "commit: " + self.commit

		if self.is_merge:
			if options.merges: 
				s = s + "\nMerge:  "
				# use short merge hashes like in Git:
				parents = map(lambda p: p[0:7], self.parents) 
				s = s + " ".join(parents)
			
			if self.is_reordered and options.reasons:
				s = s + "\nMerge*: " + self.reorder_reason
				

		s = s + "\nAuthor: " + self.author
		s = s + "\nDate:   " + self.date
		# TODO: Less hacky message indentation:
		s = s + "\n" + "\n".join(self.message)
		s = s + "\n"
		return s
		
	@property
	def commit_line(self):
		"""A commit: line that contains the commit and its parents hashes."""
		hashes = [self.commit[0:16]]
		hashes.extend([p[0:8] for p in self.parents])
		return "commit: " + " ".join(hashes)


	@property
	def is_merge(self): return len(self.parents) > 1

	@property
	def has_parent(self): return len(self.parents) > 0

	@property
	def is_reordered(self):
		"""Return true iff lhs/rhs reordering has taken place."""
		if not self.is_merge: return False
		return self.parents != self.orig_parents

	def lhs(self):
		"""Get the "left-hand-side" of a merge.
		Unlike in Git, this is not specified by the order of the parents, but is 
		calculated in a way to make history most readable."""
		if not self.has_parent: return None
		else: return self.parents[0]

	def rhs(self):
		"""Return all parents but the lhs."""
		return self.parents[1:]

	def __calc_lhs(self):
		# Defaults:
		self.reorder_reason = None 
		
		if not self.is_merge: return # Nothing to do
		
		if self.is_pull:
			# A pull is always two commits.  Switch which one is on left:
			self.reorder_reason = "Treating pull as merge into mainline."
			self.parents.reverse()
			return

	def unique_commits(self, parent):
		"""Given parent, which is one of the parents of this commit, return a list
		of commit IDs (including parent) which are found in the history of parent
		but not any of the other parents."""
		
		
		parents = set(self.parents)
		if parent not in parents:
			raise Exception("Parent {} not a parent of {}!".format(parent, self.commit))
			
		
		parents.remove(parent)
		
		return git_unique_commits(parent, parents)

	# Git changes the default merge commit message depending on the type of merge. 
	# For details, see fmt_merge_msg_title() in 
	# https://github.com/git/git/blob/master/builtin/fmt-merge-msg.c
	# Note: "remote-tracking branch" used to be "remote branch": 
	# https://github.com/git/git/commit/13931236b9ee2895a98ffdbdacbd0f895956d8a8#L2L103
	# 'git pull' does 'git fetch' then 'git merge FETCH_HEAD'
	# Python 2.6 dosn't support non-capturing groups:  :(
	__pull_pat = re.compile("[ ]*Merge (remote(-tracking)? )?branch '(.+/)?(.+)'( of ([^ ]+))?( into (.*))?")

	@property
	def is_pull(self):
		"""Try to detect if this was the result of a 'git pull' from the commit message.
		"""
		# ex:     Merge branch 'upstream' of ssh://url/to/git into myBranch
		if len(self.parents) != 2: return False
		for line in self.message:
			match = self.__pull_pat.match(line)
			if not match: continue
			merge_from = match.group(4)
			# the "into" part is omitted if we're working on master:
			merge_into = match.group(8) or "master"
			#Merged an upstream branch w/ same name?  It was a pull.
			return merge_from == merge_into 
		return False

	
def logHistory(commit, printer=GitIndent()):
	while commit:
		# If we've reached a point that's already contained in LHS
		# history, stop printing:
		if not printer.should_print(commit): break 

		info = CommitInfo.from_commit(commit)
		if info.is_merge and printer.level >= options.max_depth:
			# Print truncated merge info:
			printer.println("(Skipping merge " + info.commit_line + ")")
			# Don't indent further:
			level = printer.level
		else:
			# Print full info & indent children:
			printer.println(info)
			# allow autoindent:
			level = None
			
		for parent in info.rhs():
			inner_printer = printer.indent(limit_commits=info.unique_commits(parent), level=level)
			logHistory(parent, inner_printer)
		# Continue logging LHS:
		commit = info.lhs()

# Use Optparse for 2.6 compatibility:
import optparse
parser = optparse.OptionParser()
parser.add_option("-m", "--merges", action="store_true", dest="merges", default=False
	, help="Show the Merge: ... line with parent IDs for merge commits."
)
parser.add_option("-r", "--reasons", action="store_true", dest="reasons", default=False
	, help="Show an added Merge*: line with the reason why parents were reordered."
)
parser.add_option("-w", "--width", dest="width", default=None
	, help="Set the column width to wrap the output."
)
parser.add_option("-x", "--max-depth", dest="max_depth", default=4
    , help="Maximum indentation depth."
)

(options, args) = parser.parse_args()


def main():
	with redirect_output():
		if args:
			commit = args[0]
		else:
			commit = "HEAD"
		logHistory(commit)

def redirect_output():
	if not options.width:
		options.width = detect_width()
	if not sys.stdout.isatty():
		# Nothing to do:
		return FakeRedirector()
	# Otherwise, pipe our output to 'less':
	# -S Don't wrap.  (We'll do it better.) 
	# -F Exit immediately if no scrolling necessary
	# -X Fix -F on OSX.
	return OutputRedirector(["less", "-S", "-F", "-X"])
	
class FakeRedirector:
	def __enter__(self):
		pass
	def __exit__(self, type, value, traceback):
		pass

class OutputRedirector(FakeRedirector):
	def __init__(self, cmd):
		self._stdout = sys.stdout
		self._stderr = sys.stderr
		p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
		sys.stdout = p.stdin
		sys.stderr = p.stdin
		self.proc = p

	def __exit__(self, type, value, traceback):
		# Restore stdout/stderr: 
		sys.stdout = self._stdout
		sys.stderr = self._stderr
		p = self.proc
		p.stdin.close() # let proc know we're done writing.
		p.wait() # for the user to finish using proc.

		# Suppress "Broken Pipe" error:
		# Likely just means that the user quit less:
		if type is IOError and value.errno == 32:
			return True
		

def detect_width(default=80):
	# First try *nix detection.  Nabbed from console.py:
	try:
		import fcntl # will fail on non-*nix
		import array
		import termios
		terminfo = fcntl.ioctl(sys.stderr, termios.TIOCGWINSZ, "\0" * 8)
		width =  array.array("h", terminfo)[1]
		return width
	except:
		# Fallback to the "default" size
		return default 


if __name__ == "__main__":
	main()
