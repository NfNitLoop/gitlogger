#!/usr/bin/python

"""
This script prints a hierarchical log of git history that is designed to be
human readable.  It has these characteristics: 

* "Mainline" history goes down the left-hand side

* Following a merge commit, commits which were merged into "mainline" by that
merge are listed indented and marked with an indentation guide.

* Each commit is listed only once.  Commits will NOT be displayed in right-hand
side merge if they are also part of the LHS.  

* Pulls are detecetd and displayed as a merge into mainline

* Thus, it's easy to eyeball what got merged into mainline, and when.

Recommended usage: 
cd yourGitDir
log | less -S
"""

import subprocess
from subprocess import PIPE
import sys
import re

def get_output(*cmd):
	"""Run a command and return its output."""	
	p = subprocess.Popen(cmd, stderr=PIPE, stdout=PIPE)
	(out, err) = p.communicate()
	if err: 
		raise Exception(err)
	return out

def git_unique_commits(commit, others):
	"""Return a set of commits found in the history of commit, but not others."""
	if len(others) < 1:
		raise Exception("Others can't be empty. At least not if you want a small set of commits.")
	cmd = ["git", "log", "--pretty=format:%H", commit, "--not"]
	cmd.extend(others)
	return set(get_output(*cmd).split("\n"))
	

# TODO: Make this a cache:
__commits = {}
def lookup_commit(commit):
	"""Get a cached CommitInfo.  Otherwise look up a batch of them to save on calls to git."""
	if __commits.has_key(commit): return __commits[commit]
	else: return fetch_commits(commit)

def fetch_commits(commit, fetch=1000):
	out = get_output("git", "log", "-n", str(fetch), "--parents", "--no-decorate", commit)
	lines = out.split("\n")
	log_lines = []
	infos = []
	for line in lines:
		if line.startswith("commit ") and log_lines:	
			#Add the previous commit to the cache: 
			infos.append(CommitInfo(log_lines))
			log_lines = []
		log_lines.append(line)
	# Catch the last commit:
	if log_lines:
		infos.append(CommitInfo(log_lines))

	# Add them to the cache:
	for info in infos: __commits[info.commit] = info
	# Return the first one.  The name we used to look it up 
	# Might not match its commit.  (Ex: HEAD) 
	return infos[0]
			
			
	

# The sortof key/value pattern used in git log:
__kv_pat = re.compile("^([^: ]+):?[ ]+(.*)$")

def getKeyValue(line):
	"""Split a line up into its key/value pair, returned as a tuple."""
	match = __kv_pat.match(line)
	if not match: raise "Not a key/value line: " + line
	return match.group(1,2)
	
def remove_message_padding(line):
	"""Git commit messages are padded with 4 spaces.  This removes them."""	
	return line[4:]

class CommitInfo(object):
	@staticmethod
	def from_commit(commit):
		#return CommitInfo(getCommit(commit))
		return lookup_commit(commit)

	def __init__(self, lines):
		data = {}
		count = 0
		for line in lines:	
			if not line: break # end on blank line
			(k,v) = getKeyValue(line)
			data[k] = v
			count = count + 1

		# Break parents out of the commit:
		commit = data["commit"].split(" ")
		self.commit = commit[0]
		self.parents = commit[1:]
		# Save the original order in case parents get reordered: 
		self.orig_parents = self.parents[:]
		self.date = data["Date"]
		self.author = data["Author"]
		
		# Count is a blank line.
		# Git outputs a line return after the messages so the CLI will be on a new line
		# But it's not part of the message:
		message_lines = lines[count+1:-1]
		self.message = message_lines

		# Calculate whether the LHS needs to be changed to simplify logging:
		self.__calc_lhs()
		
		

	def __str__(self):
		s =       "commit: " + self.commit

		if self.is_merge:
			if options.merges: 
				s = s + "\nMerge:  "
				# use short merge hashes like in Git:
				parents = map(lambda p: p[0:7], self.parents) 
				s = s + " ".join(parents)
			
			if self.is_reordered and options.reasons:
				s = s + "\nMerge*: " + self.reorder_reason
				

		s = s + "\nAuthor: " + self.author
		s = s + "\nDate:   " + self.date
		# TODO: Less hacky message indentation:
		s = s + "\n" + "\n".join(self.message)
		s = s + "\n"
		return s
		
	@property
	def commit_line(self):
		"""A commit: line that contains the commit and its parents hashes."""
		hashes = [self.commit[0:16]]
		hashes.extend([p[0:8] for p in self.parents])
		return "commit: " + " ".join(hashes)


	@property
	def is_merge(self): return len(self.parents) > 1

	@property
	def has_parent(self): return len(self.parents) > 0

	@property
	def is_reordered(self):
		"""Return true iff lhs/rhs reordering has taken place."""
		if not self.is_merge: return False
		return self.parents != self.orig_parents

	def lhs(self):
		"""Get the "left-hand-side" of a merge.
		Unlike in Git, this is not specified by the order of the parents, but is 
		calculated in a way to make history most readable."""
		if not self.has_parent: return None
		else: return self.parents[0]

	def rhs(self):
		"""Return all parents but the lhs."""
		return self.parents[1:]

	def __calc_lhs(self):
		# Defaults:
		self.reorder_reason = None 
		
		if not self.is_merge: return # Nothing to do
		
		if self.is_pull:
			# A pull is always two commits.  Switch which one is on left:
			self.reorder_reason = "Treating pull as merge into mainline."
			self.parents.reverse()
			return

	def unique_commits(self, parent):
		"""Given parent, which is one of the parents of this commit, return a list
		of commit IDs (including parent) which are found in the history of parent
		but not any of the other parents."""
		
		
		parents = set(self.parents)
		if parent not in parents:
			raise Exception("Parent {} not a parent of {}!".format(parent, self.commit))
			
		
		parents.remove(parent)
		
		return git_unique_commits(parent, parents)

	def walk_lhs(self):
		"""Generate CommitInfo objects down the lhs of the history, starting with self."""
		info = self
		while info: 
			yield info
			parent = info.lhs()
			info = CommitInfo.from_commit(parent)

	# Git changes the default merge commit message depending on the type of merge. 
	# For details, see fmt_merge_msg_title() in 
	# https://github.com/git/git/blob/master/builtin/fmt-merge-msg.c
	# Note: "remote-tracking branch" used to be "remote branch": 
	# https://github.com/git/git/commit/13931236b9ee2895a98ffdbdacbd0f895956d8a8#L2L103
	# 'git pull' does 'git fetch' then 'git merge FETCH_HEAD'
	# Python 2.6 dosn't support non-capturing groups:  :(
	__pull_pat = re.compile("[ ]*Merge (remote(-tracking)? )?branch '(.+/)?(.+)'( of ([^ ]+))?( into (.*))?")

	@property
	def is_pull(self):
		"""Try to detect if this was the result of a 'git pull' from the commit message.
		"""
		# ex:     Merge branch 'upstream' of ssh://url/to/git into myBranch
		if len(self.parents) != 2: return False
		for line in self.message:
			match = self.__pull_pat.match(line)
			if not match: continue
			merge_from = match.group(4)
			# the "into" part is omitted if we're working on master:
			merge_into = match.group(8) or "master"
			#Merged an upstream branch w/ same name?  It was a pull.
			return merge_from == merge_into 
		return False

	
def logHistory(start_commit, excludes=None, level=0, max_depth=5):
	"""
	Log history down the left-hand side. Recursively log inner parts. 

	commit -- the commit at which to start logging.
	excludes -- a sequence of commit IDs whose history should be EXCLUDED when 
		deciding what to show in merge history.
	level -- The level of indentation we're currently at. 
	"""


	if level > max_depth: level = max_depth

	excludes = excludes or set()
	includes = None
	if excludes: 
		includes = git_unique_commits(start_commit, excludes)

	def should_print(commit):
		return (not excludes) or (commit in includes)
		
	info = CommitInfo.from_commit(start_commit)	

	for info in info.walk_lhs():
		if not should_print(info.commit): 
			# We've reached some history that's been excluded.
			break 

		if info.is_merge and level >= max_depth:
			# Print truncated merge info:
			print_indented("(Skipping merge " + info.commit_line + ")", level=level)
		else:
			# Print full info & indent children:
			print_indented(info, level=level)
			
		for parent in info.rhs():
			new_excludes = set(info.parents)
			new_excludes.remove(parent)
			new_excludes.update(excludes)
			
			logHistory(parent, excludes=new_excludes, level=(level + 1), max_depth=max_depth)

def print_indented(msg, level=0, left="|   "):
	prefix = left * level

	if type(msg) is list:
		lines = msg
	else:
		lines = str(msg).split("\n")

	for line in lines:
		print prefix + line

# Use Optparse for 2.6 compatibility:
import optparse
parser = optparse.OptionParser()
parser.add_option("-m", "--merges", action="store_true", dest="merges", default=False
	, help="Show the Merge: ... line with parent IDs for merge commits."
)
parser.add_option("-r", "--reasons", action="store_true", dest="reasons", default=False
	, help="Show an added Merge*: line with the reason why parents were reordered."
)
parser.add_option("-w", "--width", dest="width", default=None
	, help="Set the column width to wrap the output."
)
parser.add_option("-x", "--max-depth", dest="max_depth", default=4
    , help="Maximum indentation depth."
)

(options, args) = parser.parse_args()


def main():
	with redirect_output():
		if args:
			commit = args[0]
		else:
			commit = "HEAD"
		logHistory(commit)

def redirect_output():
	if not options.width:
		options.width = detect_width()
	if not sys.stdout.isatty():
		# Nothing to do:
		return FakeRedirector()
	# Otherwise, pipe our output to 'less':
	# -S Don't wrap.  (We'll do it better.) 
	# -F Exit immediately if no scrolling necessary
	# -X Fix -F on OSX.
	return OutputRedirector(["less", "-S", "-F", "-X"])
	
class FakeRedirector:
	def __enter__(self):
		pass
	def __exit__(self, type, value, traceback):
		pass

class OutputRedirector(FakeRedirector):
	def __init__(self, cmd):
		self._stdout = sys.stdout
		self._stderr = sys.stderr
		p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
		sys.stdout = p.stdin
		sys.stderr = p.stdin
		self.proc = p

	def __exit__(self, type, value, traceback):
		# Restore stdout/stderr: 
		sys.stdout = self._stdout
		sys.stderr = self._stderr
		p = self.proc
		p.stdin.close() # let proc know we're done writing.
		p.wait() # for the user to finish using proc.

		# Suppress "Broken Pipe" error:
		# Likely just means that the user quit less:
		if type is IOError and value.errno == 32:
			return True
		

def detect_width(default=80):
	# First try *nix detection.  Nabbed from console.py:
	try:
		import fcntl # will fail on non-*nix
		import array
		import termios
		terminfo = fcntl.ioctl(sys.stderr, termios.TIOCGWINSZ, "\0" * 8)
		width =  array.array("h", terminfo)[1]
		return width
	except:
		# Fallback to the "default" size
		return default 


if __name__ == "__main__":
	main()
