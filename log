#!/usr/bin/python

import subprocess
from subprocess import PIPE
import sys
import re

class IndentPrinter(object):
	"""Utility to print lines at a given indent level."""
	def __init__(self, level=0, width=4):
		self.level = level
		self.width = width
		prefix = " " * width
		prefix = "|" + prefix[1:]
		prefix = prefix * level
		self.prefix = prefix

	def println(self, lines):
		for line in str(lines).split("\n"):
			print(self.prefix + line)

	def indent(self):
		return IndentPrinter(level=self.level + 1, width=self.width)
		
class GitIndent(IndentPrinter):
	"""This indenter remembers the context of the commits which it is outputting. 
	This allows us to check that we're not displaying duplicate entries inside of indent.
	"""
	def __init__(self, level=0, width=4, commits=[], parent=None):
		IndentPrinter.__init__(self, level=level, width=width)
		self.commits = commits
		self.parent = parent
		
	def indent(self):
		return GitIndent(
			level=self.level + 1
			, width=self.width
			, parent=self
		)

	def is_in_lhs(self, commit):
		"""Return true if this commit will be in some other part of the left-hand-side.
		"""
		for other_commit in self.commits:
			if contains(other_commit, commit): return True

		if self.parent: return self.parent.is_in_lhs(commit)
		else: return False

	
def contains(other_commit, commit):
	"""Return true of commit is contained in other_commit's DAG."""
	cmd = ["git", "merge-base", commit, other_commit]
	p = subprocess.Popen(cmd, stdin=PIPE, stdout=PIPE)
	(out, err) = p.communicate()
	if err: 
		raise Exception(err)

	lines = out.split("\n")
	base = lines[0]
	return base == commit
		
def getCommit(commit):
	cmd = ["git", "log", "-n", "1", "--parents", commit]
	p = subprocess.Popen(cmd, stdin=PIPE, stdout=PIPE)
	(out, err) = p.communicate()
	if err: 
		raise err
	return out

# The sortof key/value pattern used in git log:
__kv_pat = re.compile("^([^: ]+):?[ ]+(.*)$")

def getKeyValue(line):
	"""Split a line up into its key/value pair, returned as a tuple."""
	match = __kv_pat.match(line)
	if not match: raise "Not a key/value line: " + line
	return match.group(1,2)
	
def remove_message_padding(line):
	"""Git commit messages are padded with 4 spaces.  This removes them."""	
	return line[4:]

class CommitInfo(object):
	def __init__(self, commit_text):
		lines = commit_text.split("\n")
		data = {}
		count = 0
		for line in lines:	
			if not line: break # end on blank line
			(k,v) = getKeyValue(line)
			data[k] = v
			count = count + 1

		# Break parents out of the commit:
		commit = data["commit"].split(" ")
		self.commit = commit[0]
		self.parents = commit[1:]
		self.date = data["Date"]
		self.author = data["Author"]
		
		# Count is a blank line.
		# Git outputs a line return after the messages so the CLI will be on a new line
		# But it's not part of the message:
		message_lines = lines[count+1:-1]
		self.message = message_lines

		# Calculate whether the LHS needs to be changed to simplify logging:
		self.__calc_lhs()
		
		

	def __str__(self):
		s =       "commit: " + self.commit

		if self.is_merge(): 
			if self.is_reordered(): s = s + "\nMerge*: "
			else: s = s + "\nMerge:  "
			parents = ([self.lhs()] + self.other_parents())
			# use short merge hashes like in Git:
			parents = map(lambda p: p[0:7], parents) 
			s = s + " ".join(parents)

		s = s + "\nAuthor: " + self.author
		s = s + "\nDate:   " + self.date
		# TODO: Less hacky message indentation:
		s = s + "\n" + "\n".join(self.message)
		# if self.reorder_reason:
		# 	s = s + "\n    (* " + self.reorder_reason + " *)"
		s = s + "\n"
		return s

	def is_merge(self): return len(self.parents) > 1
	def has_parent(self): return len(self.parents) > 0

	def is_reordered(self):
		"""Return true iff lhs/rhs reordering has taken place."""
		if not self.is_merge(): return False
		new_parents = [self.lhs()] + self.other_parents()
		return new_parents != self.parents

	def lhs(self):
		"""Get the "left-hand-side" of a merge.
		Unlike in Git, this is not specified by the order of the parents, but is 
		calculated in a way to make history most readable."""
		return self.__lhs

	def other_parents(self):
		"""Return all parents but the lhs."""
		return self.__rhs

	def __calc_lhs(self):
		# Defaults:
		self.__lhs = None  # The new left-hand-side (first parent) of the merge.
		self.__rhs = [] # The rest of the merge parents
		self.reorder_reason = None 
		
		if not self.has_parent(): return # Nothing to calculate. 

		pull_branch = self.is_pull()
		if pull_branch:
			self.__lhs = self.parents[1]
			self.__rhs = self.parents[0:1] #(non-inclusive)
			self.reorder_reason = "Treating pull of '" + pull_branch + "' as merge into mainline."
			return

		# Else, default to git-lhs:
		self.__lhs = self.parents[0]
		self.__rhs = self.parents[1:]
			

	__pull_pat = re.compile("[ ]*Merge branch '(.+)' of .* into .*")

	def is_pull(self):
		"""Try to detect if this was the result of a 'git pull' from the commit message.
		Returns the name of the upstream branch if we detected a pull.  Else: None.
		"""
		# ex:     Merge branch 'upstream' of ssh://url/to/git into myBranch
		if len(self.parents) != 2: return False
		for line in self.message:
			match = self.__pull_pat.match(line)
			if match: return match.group(1)
		return None
		


def getCommitInfo(commit):
	return CommitInfo(getCommit(commit))
	
def logHistory(commit, printer=GitIndent()):
	while commit:
		# If we've reached a point that's already contained in LHS
		# history, stop printing:
		if printer.is_in_lhs(commit): break 

		info = getCommitInfo(commit)
		printer.println(info)
		indent = printer.indent()
		indent.commits = [info.lhs()]
		for parent in info.other_parents():
			# Don't display duplicate data:
			if indent.is_in_lhs(parent): continue
			logHistory(parent, indent)
		# Continue logging LHS:
		commit = info.lhs()

def main(args):
	if args:
		commit = args[0]
	else:
		commit = "HEAD"
	logHistory(commit)

if __name__ == "__main__":
	main(sys.argv[1:])

