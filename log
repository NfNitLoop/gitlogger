#!/usr/bin/python

"""
This script prints a hierarchical log of git history that is designed to be
human readable.  It has these characteristics: 

* "Mainline" history goes down the left-hand side

* Following a merge commit, commits which were merged into "mainline" by that
merge are listed indented and marked with an indentation guide.

* Each commit is listed only once.  Commits will NOT be displayed in right-hand
side merge if they are also part of the LHS.  

* Pulls are detecetd and displayed as a merge into mainline

* Thus, it's easy to eyeball what got merged into mainline, and when.

Recommended usage: 
cd yourGitDir
log | less -S
"""

import subprocess
from subprocess import PIPE
import sys
import re

class IndentPrinter(object):
	"""Utility to print lines at a given indent level."""
	def __init__(self, level=0, width=4):
		self.level = level
		self.width = width
		prefix = "|" + " " * (width - 1)
		prefix = prefix * level
		self.prefix = prefix

	def println(self, lines):
		for line in str(lines).split("\n"):
			print(self.prefix + line)

	def indent(self):
		return IndentPrinter(level=self.level + 1, width=self.width)
		
class GitIndent(IndentPrinter):
	"""This indenter remembers the context of the commits which it is outputting. 
	This allows us to check that we're not displaying duplicate entries inside of indent.
	"""
	def __init__(self, level=0, width=4, commits=[], parent=None):
		IndentPrinter.__init__(self, level=level, width=width)
		self.commits = commits
		self.parent = parent
		
	def indent(self):
		return GitIndent(
			level=self.level + 1
			, width=self.width
			, parent=self
		)

	def is_in_lhs(self, commit):
		"""Return true if this commit will be in some other part of the left-hand-side.
		"""
		for other_commit in self.commits:
			if contains(other_commit, commit): return True

		if self.parent: return self.parent.is_in_lhs(commit)
		else: return False

	
def contains(other_commit, commit):
	"""Return true if commit is contained in other_commit's DAG."""
	cmd = ["git", "merge-base", commit, other_commit]
	p = subprocess.Popen(cmd, stderr=PIPE, stdout=PIPE)
	(out, err) = p.communicate()
	if err: 
		raise Exception(err)

	lines = out.split("\n")
	base = lines[0]
	return base == commit

def getCommit(commit):
	"""Get a single commit message from git."""
	cmd = ["git", "log", "-n", "1", "--parents", commit]
	p = subprocess.Popen(cmd, stderr=PIPE, stdout=PIPE)
	(out, err) = p.communicate()
	if err: 
		raise Exception(err)
	return out

# The sortof key/value pattern used in git log:
__kv_pat = re.compile("^([^: ]+):?[ ]+(.*)$")

def getKeyValue(line):
	"""Split a line up into its key/value pair, returned as a tuple."""
	match = __kv_pat.match(line)
	if not match: raise "Not a key/value line: " + line
	return match.group(1,2)
	
def remove_message_padding(line):
	"""Git commit messages are padded with 4 spaces.  This removes them."""	
	return line[4:]

class CommitInfo(object):
	def __init__(self, commit_text):
		lines = commit_text.split("\n")
		data = {}
		count = 0
		for line in lines:	
			if not line: break # end on blank line
			(k,v) = getKeyValue(line)
			data[k] = v
			count = count + 1

		# Break parents out of the commit:
		commit = data["commit"].split(" ")
		self.commit = commit[0]
		self.parents = commit[1:]
		# Save the original order in case parents get reordered: 
		self.orig_parents = self.parents[:]
		self.date = data["Date"]
		self.author = data["Author"]
		
		# Count is a blank line.
		# Git outputs a line return after the messages so the CLI will be on a new line
		# But it's not part of the message:
		message_lines = lines[count+1:-1]
		self.message = message_lines

		# Calculate whether the LHS needs to be changed to simplify logging:
		self.__calc_lhs()
		
		

	def __str__(self):
		s =       "commit: " + self.commit

		if self.is_merge(): 
			s = s + "\nMerge:  "
			# use short merge hashes like in Git:
			parents = map(lambda p: p[0:7], self.parents) 
			s = s + " ".join(parents)
			if self.is_reordered(): s = s + "\nMerge*: " + self.reorder_reason
				

		s = s + "\nAuthor: " + self.author
		s = s + "\nDate:   " + self.date
		# TODO: Less hacky message indentation:
		s = s + "\n" + "\n".join(self.message)
		s = s + "\n"
		return s

	def is_merge(self): return len(self.parents) > 1
	def has_parent(self): return len(self.parents) > 0

	def is_reordered(self):
		"""Return true iff lhs/rhs reordering has taken place."""
		if not self.is_merge(): return False
		return self.parents != self.orig_parents

	def lhs(self):
		"""Get the "left-hand-side" of a merge.
		Unlike in Git, this is not specified by the order of the parents, but is 
		calculated in a way to make history most readable."""
		if not self.has_parent(): return None
		else: return self.parents[0]

	def rhs(self):
		"""Return all parents but the lhs."""
		return self.parents[1:]

	def __calc_lhs(self):
		# Defaults:
		self.reorder_reason = None 
		
		if not self.is_merge(): return # Nothing to do
		
		if self.is_pull():
			# A pull is always two commits.  Switch which one is on left:
			self.reorder_reason = "Treating pull as merge into mainline."
			self.parents.reverse()
			return


	# Git changes the default merge commit message depending on the type of merge. 
	# For details, see fmt_merge_msg_title() in 
	# https://github.com/git/git/blob/master/builtin/fmt-merge-msg.c
	# Note: "remote-tracking branch" used to be "remote branch": 
	# https://github.com/git/git/commit/13931236b9ee2895a98ffdbdacbd0f895956d8a8#L2L103
	# 'git pull' does 'git fetch' then 'git merge FETCH_HEAD'
	# Python 2.6 dosn't support non-capturing groups:  :(
	__pull_pat = re.compile("[ ]*Merge (remote(-tracking)? )?branch '(.+/)?(.+)'( of ([^ ]+))?( into (.*))?")
	def is_pull(self):
		"""Try to detect if this was the result of a 'git pull' from the commit message.
		"""
		# ex:     Merge branch 'upstream' of ssh://url/to/git into myBranch
		if len(self.parents) != 2: return False
		for line in self.message:
			match = self.__pull_pat.match(line)
			if not match: continue
			merge_from = match.group(4)
			# the "into" part is omitted if we're working on master:
			merge_into = match.group(8) or "master"
			#Merged an upstream branch w/ same name?  It was a pull.
			return merge_from == merge_into 
		return False

def getCommitInfo(commit):
	return CommitInfo(getCommit(commit))
	
def logHistory(commit, printer=GitIndent()):
	while commit:
		# If we've reached a point that's already contained in LHS
		# history, stop printing:
		if printer.is_in_lhs(commit): break 

		info = getCommitInfo(commit)
		printer.println(info)
		indent = printer.indent()
		indent.commits = [info.lhs()]
		for parent in info.rhs():
			# Don't display duplicate data:
			if indent.is_in_lhs(parent): continue
			logHistory(parent, indent)
		# Continue logging LHS:
		commit = info.lhs()

def main(args):
	if args:
		commit = args[0]
	else:
		commit = "HEAD"
	logHistory(commit)

if __name__ == "__main__":
	main(sys.argv[1:])

