#!/usr/bin/env python3

"""
This script prints a hierarchical log of git history that is designed to be
human readable.  It has these characteristics: 

* "Mainline" history goes down the left-hand side

* Following a merge commit, commits which were merged into "mainline" by that
merge are listed indented and marked with an indentation guide.

* Each commit is listed only once.  Commits will NOT be displayed in right-hand
side merge if they are also part of the LHS.  

* Pulls are detecetd and displayed as a merge into mainline

* Thus, it's easy to eyeball what got merged into mainline, and when.

Recommended usage: 
cd yourGitDir
log | less -S
"""

import subprocess
from subprocess import PIPE, Popen, STDOUT
import sys
import re
import os.path

from collections import OrderedDict


def main():
    with pipe_through_less():
        if args:
            commit = args[0]
        else:
            commit = "HEAD"
        logger = Logger()
        logger.log(commit)

class Repo:
    def __init__(self, path, git_exe="git"):
        self.path = path
        self.git_exe = git_exe
                
    def get_commits(self, start_commit="HEAD", excludes=None):
        """
        Return a generator of CommitInfo items.
        start_commit: where to start logging.
        excludes: a list of commits we should exclude (with --not) from logged history.
        """
        
        # Store information about the current Commit:
        info = None

        # Make a list of actions we should try in order if a re pattern matches:
        handler = _LineHandler()
        @handler.on("^commit (.+)$")
        def handle(match):
            nonlocal info
            prior_info = info
            info = CommitInfo()
            info.id = match.group(1)
            return prior_info
            
        @handler.on("^parent (.+)$")
        def handle(match):
            info.parents.append(match.group(1))
            
        @handler.on("^author (.+)$")
        def handle(match):
            info.author = match.group(1)
            
        @handler.on("^committer (.+)$")
        def handle(match):
            info.committer = match.group(1)
            
        @handler.on("^    (.*)$")
        def handle(match):
            info.message_lines.append(match.group(1))
            
        @handler.on("^tree .*|$")
        def handle(match):
            pass # do nothing, ignore these.
            
        cmd = [self.git_exe, "log", "--format=raw"]
        if start_commit:
            cmd.append(start_commit)
        if excludes:
            cmd.append("--not")
            cmd.extend(excludes)
                                    
        p = Popen(
            cmd,
            cwd=self.path,
            stdout=PIPE,
            stderr=STDOUT,
            universal_newlines=True, # text mode.
            #bufsize=1 # line
        )
        # Iterate through lines of output, building up a CommitInfo object:
        with p:
            for line in p.stdout:
                value = handler.handle(line)
                if value is not None:
                    yield value
                    
        if info and info.id:
            yield info

class _LineHandler:
    """Handle line-based text input via regexes."""
    
    def __init__(self):
        self.handlers = OrderedDict()
        
    def handle(self, line):
        """Handle a line of input with previously declared "@on" handlers."""
        for pattern, callback in self.handlers.items():
            match = pattern.match(line)
            if not match: continue
            return callback(match)
            
        raise Exception("Unhandled line:", line)
        
    def on(self, expression):
        """Decorator: Hook a regular expression up to an action."""
        
        pattern = re.compile(expression)
        
        def decorator(func):
            self.handlers[pattern] = func
            return func

        return decorator
    
        
class CommitInfo:
    def __init__(self, id=None, parents=None, message_lines=None, author=None):
        self.id = id
        self.parents = parents
        self.message_lines = message_lines
        self.author = author
        
        if self.parents is None:
            self.parents = []
        if self.message_lines is None:
            self.message_lines = []
            
    @property
    def message(self):
        return "\n".join(self.message_lines)

    @property
    def is_merge(self): return len(self.parents) > 1

    @property
    def has_parent(self): return len(self.parents) > 0

    def __str__(self):
        lines = []
        lines.append("commit " + self.id)
        if self.is_merge:
            lines.append("Merge: " + " ".join(self.parents))
        lines.append("Author: " + self.author)
        lines.append("Date: TODO")
        lines.append("")
        for m in self.message_lines:
            lines.append("    " + m)
        lines.append("")
        return "\n".join(lines)

class IndentPrinter(object):
    """Utility to print lines at a given indent level."""
    def __init__(self, level=0, width=4):
        self.level = level
        self.width = width
        prefix = "|" + " " * (width - 1)
        prefix = prefix * level
        self.prefix = prefix

    def print(self, text):
        for line in str(text).split("\n"):
            print(self.prefix, line, sep="")
        # TODO 
        sys.stdout.flush()

    def indent(self):
        return IndentPrinter(level=self.level + 1, width=self.width)

class Logger:
    def __init__(self, repo=None, max_depth=4):
        if repo is None:
            repo = Repo(path=".")

        self.repo = repo
        self.max_depth = max_depth

    def log(self, commit_id, printer=IndentPrinter(), excludes=None):
        if excludes is None:
            excludes = set()
        
        commits = Iterator(self.repo.get_commits(commit_id, excludes=excludes))
        
        while commits.has_next:
            commit = commits.next()
            
            printer.print(commit)
            
            if not commit.is_merge:
                continue
                
            # At each merge point, we stop logging and start up (at least) two 
            # separate processes to log each merge parent separately.
            commits.close()
            
            # TODO: Maybe allow dynamically choosing which side to treat as the
            # "left hand side". 
            lhs = commit.parents[0]
            
            # In *this* loop, we'll continue logging down the LHS and assume
            # it's the "main" branch of history:
            commits = Iterator(self.repo.get_commits(lhs, excludes=excludes))
            
            # But first, log each of the "right-hand" sides as indented merges:
            rh_sides = commit.parents[1:]

            if printer.level >= self.max_depth:
                printer.print("(Max indent reached. Flattening.)")
                printer.print("")
                new_printer = printer
            else:
                new_printer = printer.indent()

            for rhs in rh_sides:
                rhs_excludes = excludes.union(set(commit.parents) - {rhs})
                self.log(rhs, printer=new_printer, excludes=rhs_excludes)
                    
class Iterator:
    """
    Wraps a Python iterator with a classic Iterator interface which has
    .next(), .peek(), .has_next, and .close() methods.
    """
    
    def __init__(self, iterable):
        self.inner = iter(iterable)
        # either None (no next value), or a 1-tuple containing the value.
        self._next_value = None
        
    def peek(self):
        """Peek at the next value. Raises StopIteration if the value doesn't exist."""
        
        if not self._next_value:
            self._next_value = (next(self.inner),)
            
        return self._next_value[0]
        
    def next(self):
        """Return the next value, or raises StopIteration if no such value."""
        if self._next_value:
            value = self._next_value[0]
            self._next_value = None
            return value
            
        return next(self.inner)
        
    @property
    def has_next(self):
        try:
            self.peek()
            return True
        except StopIteration:
            return False
    
    # Iterator is also an iterator
    def __next__(self):
        return self.next()
        
    def __iter__(self):
        return self
        
    def close(self):
        if hasattr(self.inner, "close"):
            self.inner.close()
    
    def __del__(self):
        self.close()

# Use Optparse for 2.6 compatibility:
import optparse
parser = optparse.OptionParser()
parser.add_option("-m", "--merges", action="store_true", dest="merges", default=False
    , help="Show the Merge: ... line with parent IDs for merge commits."
)
parser.add_option("-r", "--reasons", action="store_true", dest="reasons", default=False
    , help="Show an added Merge*: line with the reason why parents were reordered."
)
parser.add_option("-w", "--width", dest="width", default=None
    , help="Set the column width to wrap the output."
)
parser.add_option("-x", "--max-depth", dest="max_depth", default=4
    , help="Maximum indentation depth."
)

(options, args) = parser.parse_args()



def pipe_through_less():
    """Iff the output is an interactive terminal, automatically pipe through `less`."""
    # TODO: Don't rely on module-globals. Gross.
    if not options.width:
        options.width = detect_width()
    if not sys.stdout.isatty():
        # Nothing to do:
        return FakeRedirector()
    # Otherwise, pipe our output to 'less':
    # -S Don't wrap.  (We'll do it better.) 
    # -F Exit immediately if no scrolling necessary
    # -X Fix -F on OSX.
    return OutputRedirector(["less", "-S", "-F", "-X"])
    
class FakeRedirector:
    def __enter__(self):
        pass
    def __exit__(self, type, value, traceback):
        pass

class OutputRedirector(FakeRedirector):
    def __init__(self, cmd):
        self._stdout = sys.stdout
        self._stderr = sys.stderr
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE, universal_newlines=True)
        sys.stdout = p.stdin
        sys.stderr = p.stdin
        self.proc = p

    def __exit__(self, type, value, traceback):
        # Restore stdout/stderr: 
        sys.stdout = self._stdout
        sys.stderr = self._stderr
        p = self.proc
        try:
            p.stdin.close() # let proc know we're done writing.
        except BrokenPipeError:
            pass
        p.wait() # for the user to finish using proc.

        # Suppress "Broken Pipe" error:
        # Likely just means that the user quit less:
        if type is BrokenPipeError:
            return True
        

def detect_width(default=80):
    # First try *nix detection.  Nabbed from console.py:
    try:
        import fcntl # will fail on non-*nix
        import array
        import termios
        terminfo = fcntl.ioctl(sys.stderr, termios.TIOCGWINSZ, "\0" * 8)
        width =  array.array("h", terminfo)[1]
        return width
    except:
        # Fallback to the "default" size
        return default 


if __name__ == "__main__":
    main()
